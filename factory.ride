# TODO:
# 1. Apply multiplicator

{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#-------------------Private functions----------------------
func convertJsonArrayToList(jsonArray: String, splitSymbol: String) = {
   jsonArray.split(splitSymbol) 
}

func getStringByAddressAndKey(address: Address, key: String) = {
     getString(address, key).valueOrElse("")
}

func getBoolByKey(key: String) = {
    getBoolean(this, key).valueOrElse(false)
}

#------------------ Variables -----------------------
let keyAssetCode = 0
let keyAssetId = 1
let keyAssetStatus = 2
let keyAssetPriceDecimals = 3
let keyAssetBakingAsset = 4
let keyOvercollateralPercentage = 5
let keyMinPool = 6
let keyPriceOracleAddress = 7
let keyMinBuyPayment = 8
let keyMinSellPayment = 9
let keyBuyLockInterval = 10
let keySellLockInterval = 11
let keyBuyFee = 12
let keySellFee = 13
let keyPoolRedemptionTimeout = 14
let SEPARATOR = "__"
let COMMONCONFIG = "commonConfig"

#------------------- Constructor -------------------------
let neutrinoContractAddressKey =   "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "neutrinoContractAddress"
let minimunPoolFundingAmountKey =  "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "minimumPoolFundingAmount"
let isInitializedKey =             "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "initialized"
let currentAssetIndexKey =         "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "predefinedAssetsActiveIndex" # should be set as 1 with first contract deploy
let assetsAddressListKey =         "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "predefinedAssetsList"
let mainMultiplicatorKey =         "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "multiplicator" # all digits to save with multiplicator, e.g. 20 is stored as 20 * multiplicator
let debtTokenIdKey =               "%s" + SEPARATOR + COMMONCONFIG + SEPARATOR +  "debtTokenId" # all digits to save with multiplicator, e.g. 20 is stored as 20 * multiplicator

#------------------- Keys on other contracts ---------------------------------
let neutrinoAssetIdKey =    "neutrino_asset_id" # from Neutrino contract
let nsbtAssetIdKey =        "bond_asset_id"         # from Neutrino contract
let defoAssetIdKey =        "defoAssetId" # key on synthetic asset contract that represents issued asset id
let assetPriceKey =         "assetPrice" # key on control contract that represents price
let setAssetScriptTxIdKey = "assetScriptTxId" # key on synthetic asset contract that represents issued asset transaction id

#---------------------- Keys on current contract --------------------------
# main static config of an asset
func getAssetConfigKey(assetAddress: String) = "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress + SEPARATOR + "config"

# dynamic asset parameters
func getAssetInitHeightKey(assetAddress: String) = "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress + SEPARATOR + "initHeight" 
func getAssetActivateHeightKey(assetAddress: String) = "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress + SEPARATOR + "activateHeight" 
func getAssetCurrrentPoolAmountKey(assetAddress: String) = "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress +  SEPARATOR + "currentPool"
func getAssetMaxPoolAmountKey(assetAddress: String) =  "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress + SEPARATOR + "maxPool"

func getAssetAddressByCodeKey(assetCode: String) =  "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetCode + SEPARATOR + "address"
func getAssetMetaKey(assetAddress: String) =  "%s%s%s" + SEPARATOR + "defoAsset" + SEPARATOR + assetAddress +  SEPARATOR + "meta" 
func getAssetAddressByAssetIdKey(assetId: String) =  "%s%s%s" + SEPARATOR + "defoAssetId" + SEPARATOR + assetId + SEPARATOR + "contract" # key on factory contract that links issued asset id with synthetic asset contract

func getPoolMakerParticipationAmountKey(assetAddress: String, poolMakerAddress: String) =  "%s%s%s%s" + SEPARATOR + "pool" + SEPARATOR + assetAddress + SEPARATOR + poolMakerAddress + SEPARATOR + "amount"
func getPoolMakerParticipationMaxAmountKey(assetAddress: String, poolMakerAddress: String) = "%s%s%s%s" + SEPARATOR + "pool" + SEPARATOR + assetAddress + SEPARATOR + poolMakerAddress + SEPARATOR + "maxAmount"
func getPoolMakerLockedAmountKey(assetAddress: String, poolMakerAddress: String) = "%s%s%s%s" + SEPARATOR + "pool" + SEPARATOR + assetAddress + SEPARATOR + poolMakerAddress + SEPARATOR + "lockedAmount"
func getPoolMakerUnlockHeightKey(assetAddress: String, poolMakerAddress: String) = "%s%s%s%s" + SEPARATOR + "pool" + SEPARATOR + assetAddress + SEPARATOR + poolMakerAddress + SEPARATOR + "unlockHeight"

func getAssetConfigArray(assetAddress: String) = 
        convertJsonArrayToList(getStringByAddressAndKey(this,getAssetConfigKey(assetAddress)).valueOrErrorMessage("No DEFO Asset " + assetAddress + "config present"),
    SEPARATOR)

#-------------------Global variables-------------------------
let neutrinoContract =          addressFromStringValue(getString(this,neutrinoContractAddressKey).valueOrErrorMessage("No neutrino contract specified."))
let neutrinoAssetId =           fromBase58String(getString(neutrinoContract, neutrinoAssetIdKey).valueOrErrorMessage("No USDN asset id found."))
let nsbtAssetId =               fromBase58String(getString(neutrinoContract, nsbtAssetIdKey).valueOrErrorMessage("No NSBT asset id found"))
let minimumPoolFunding =        getInteger(this, minimunPoolFundingAmountKey).valueOrErrorMessage("Minimum pool funding amount is not specified.")
let assetStatus =               ("PROPOSED","READY","ISSUED")
let predefinedAssetContracts =  getString(this, assetsAddressListKey).valueOrErrorMessage("No pool of predeployed asset contracts found.")
let predefinedAssetsList =      convertJsonArrayToList(predefinedAssetContracts, ",")
let currentAssetIndex =         getInteger(this, currentAssetIndexKey).valueOrElse(0)
let debtToken    =            fromBase58String(getString(this,debtTokenIdKey).valueOrErrorMessage("No debt token found"))

#-------------------Get functions-----------------------
func getAssetAddressByCode(assetSymbol: String) = getString(this, getAssetAddressByCodeKey(assetSymbol)).valueOrElse("")
func getAssetCode(assetConfig: List[String]) = assetConfig[keyAssetCode]
func getAssetID(assetConfig: List[String]) = assetConfig[keyAssetId]
func getAssetStatus(assetConfig: List[String]) = assetConfig[keyAssetStatus]
func getAssetPriceDecimals(assetConfig: List[String]) = parseIntValue(assetConfig[keyAssetPriceDecimals])
func getAssetBakingAssetId(assetConfig: List[String]) = assetConfig[keyAssetBakingAsset]
func getAssetOverCollateralPercent(assetConfig: List[String]) = parseIntValue(assetConfig[keyOvercollateralPercentage])
func getAssetMinRequiredPoolAmount(assetConfig: List[String]) = parseIntValue(assetConfig[keyMinPool])
func getAssetPriceOracleAddress(assetConfig: List[String]) =assetConfig[keyPriceOracleAddress]
func getMinBuyPaymentPerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keyMinBuyPayment])
func getMinSellPaymentPerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keyMinSellPayment])
func getBuyLockIntervalPerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keyBuyLockInterval])
func getSellLockIntervalPerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keySellLockInterval])
func getBuyFeePerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keyBuyFee])
func getSellFeePerAsset(assetConfig: List[String]) = parseIntValue(assetConfig[keySellFee])
func getRedemptionTimeoutBlocks(assetConfig: List[String]) = parseIntValue(assetConfig[keyPoolRedemptionTimeout])

func getAssetInitHeight(assetAddress: String) = getInteger(this,getAssetInitHeightKey(assetAddress)).valueOrElse(0)
func getAssetActivateHeight(assetAddress: String) = getInteger(this,getAssetActivateHeightKey(assetAddress)).valueOrElse(0)
func getAssetCurrentPoolAmount(assetAddress: String) = getInteger(this,getAssetCurrrentPoolAmountKey(assetAddress)).valueOrElse(0)
func getAssetMaxPoolAmount(assetAddress: String) = getInteger(this,getAssetMaxPoolAmountKey(assetAddress)).valueOrElse(0)

func getAssetMeta(assetAddress: String) = getString(this,getAssetMetaKey(assetAddress)).valueOrElse("")

func getPoolMakerParticipationAmount(assetAddress: String, poolMakerAddress: String) = getInteger(this,getPoolMakerParticipationAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerParticipationMaxAmount(assetAddress: String, poolMakerAddress: String) = getInteger(this,getPoolMakerParticipationMaxAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerLockedAmount(assetAddress: String, poolMakerAddress: String) = getInteger(this,getPoolMakerLockedAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerUnlockHeight(assetAddress: String, poolMakerAddress: String) = getInteger(this,getPoolMakerUnlockHeightKey(assetAddress, poolMakerAddress)).valueOrElse(0)

func getAssetPrice(priceOracleAddress: Address) = getInteger(priceOracleAddress, assetPriceKey).valueOrErrorMessage("No Asset price found")

func composeAssetConfigurationString(assetCode: String, assetId: String, assetStatus: String, priceDecimals: Int, backingAssetId: String, overCollateralPercent: Int, minPool: Int, priceOracleAddress: String,  
                  minBuyPayment: Int, minSellPayment: Int, buyLockInterval: Int, sellLockInterval: Int, buyFee: Int, sellFee: Int, poolRedemptionTimeout: Int) = {
    "%s%s%s%d%s%d%d%s%d%d%d%d%d%d%d" + SEPARATOR + 
    assetCode                        + SEPARATOR + 
    assetId                          + SEPARATOR + 
    assetStatus                      + SEPARATOR + 
    toString(priceDecimals)          + SEPARATOR + 
    backingAssetId                   + SEPARATOR +
    toString(overCollateralPercent)  + SEPARATOR + 
    toString(minPool)                + SEPARATOR + 
    priceOracleAddress               + SEPARATOR + 
    toString(minBuyPayment)          + SEPARATOR +
    toString(minSellPayment)         + SEPARATOR + 
    toString(buyLockInterval)        + SEPARATOR + 
    toString(sellLockInterval)       + SEPARATOR + 
    toString(buyFee)                 + SEPARATOR + 
    toString(sellFee)                + SEPARATOR + 
    toString(poolRedemptionTimeout)
}

@Callable(i)
func init(neutrinoContractAddr: String, minimunPoolFundingAmount: Int, predefinedAssetList: String, mainMultiplicator: Int ) = {
    if (i.caller == this && getBoolByKey(isInitializedKey) == false ) then {
        # TODO:
        # 6. cross  exchange coefficient
        let issueDebt =  Issue("DEFODBT", "DEFO Debt token", 1, 8, true)
        let debtTokenId = calculateAssetId(issueDebt)
        [ 
            StringEntry(neutrinoContractAddressKey,neutrinoContractAddr),
            IntegerEntry(minimunPoolFundingAmountKey,minimunPoolFundingAmount),
            StringEntry(assetsAddressListKey, predefinedAssetList),
            IntegerEntry(currentAssetIndexKey, 1),
            IntegerEntry(mainMultiplicatorKey, mainMultiplicator),
            StringEntry(debtTokenIdKey, toBase58String(debtTokenId)),
            BooleanEntry(isInitializedKey, true),
            issueDebt,
            Burn(debtTokenId, 1)
        ]
    } else []
}

# Propose new synthetic asset
# [called by user]
# TODO: add payment to initiate pool by firts pool  maker
@Callable(i)
func proposeAsset(assetCode: String, meta: String, minPool: Int, priceOracleAddress: String, overCollateralPercent: Int, backingAssetId: String, 
                  priceDecimals: Int, minBuyPayment: Int, minSellPayment: Int, buyLockInterval: Int, sellLockInterval: Int, buyFee: Int, sellFee: Int, 
                  poolRedemptionTimeout: Int) = {
    # check ticker is not present
    # check minPool amount more or equals to specified  minimum
    if(i.caller != this) 
        then throw("Operation is allowed for contract holder ATM.") 
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if (getAssetAddressByCode(assetCode) != "") 
        then throw("Asset with passed code " + assetCode + " has already been proposed.")
    else if(minPool < minimumPoolFunding)
       then throw("Minimum pool amount should be greater or equals to " + toString(minimumPoolFunding))
    else if(overCollateralPercent < 0 || priceDecimals < 0 || priceDecimals > 8 || minBuyPayment < 0 || minSellPayment < 0 || buyLockInterval < 0 || sellLockInterval < 0 
            || buyFee < 0 || sellFee < 0) 
        then throw("One of the passed parameters is invalid.")
    else {
        let priceOracleAddressValid = addressFromStringValue(priceOracleAddress).valueOrErrorMessage("Passed Price Oracle Address is not valid.")
        let assetAddress = predefinedAssetsList[currentAssetIndex]
        let defoAssetId = getString(addressFromString(assetAddress).valueOrErrorMessage(""), defoAssetIdKey).valueOrErrorMessage("No defo asset ID found.")
        
        [
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(assetCode,defoAssetId,assetStatus._1,priceDecimals,backingAssetId,overCollateralPercent,
                    minPool,priceOracleAddress,minBuyPayment,minSellPayment,buyLockInterval,sellLockInterval,buyFee, sellFee,poolRedemptionTimeout)), 

            StringEntry(getAssetAddressByCodeKey(assetCode), assetAddress),  
            StringEntry(getAssetMetaKey(assetAddress), meta),
            IntegerEntry(getAssetInitHeightKey(assetAddress), height),
            IntegerEntry(currentAssetIndexKey, currentAssetIndex + 1),
            StringEntry(getAssetAddressByAssetIdKey(defoAssetId),assetAddress)
        ]
    }
}


# Fund specified synthetic asset liquidity pool
# [called by user]
@Callable(i)
func fundLiquidityPool(assetCode: String) = {
    let assetConfigurationList = getAssetConfigArray(assetCode)

    let attachedPayment = (i.payments[0]).value()
    let assetAddress = getAssetAddressByCode(assetCode)
    # check payment is in USDN
    if(i.caller != this) 
        then throw("Operation is allowed for contract holder ATM.") 
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(attachedPayment.assetId != neutrinoAssetId) 
        then throw("Liquidity pool could be funded with USDN only.")
    # check payment amount more than 0
    else if(attachedPayment.amount == 0) 
        then throw("Incorrect attached payment amount.")
    # check asset exists
    else if(assetAddress == "")
        then throw("Cannot find liquidity pool for asset " + assetCode + ".")
    else {
        let finalPoolAmount = attachedPayment.amount + getAssetCurrentPoolAmount(assetAddress)
        let maxPoolAmount = getAssetMaxPoolAmount(assetAddress)
        
        let currentPoolMakerBalance = getPoolMakerParticipationAmount(toString(i.caller),assetAddress)
        let maxPoolMakerBalance = getPoolMakerParticipationMaxAmount(toString(i.caller),assetAddress)

        let currentPoolStatus = getAssetStatus(assetConfigurationList)
        let finalPoolStatus = if((finalPoolAmount >= getAssetMinRequiredPoolAmount(assetConfigurationList)) && (currentPoolStatus == assetStatus._1))
                    then assetStatus._2 
                        else currentPoolStatus

        # collect all keys for config
        let aCode = getAssetCode(assetConfigurationList) 
        let aID = getAssetID(assetConfigurationList)
        let aPriceDecimals = getAssetPriceDecimals(assetConfigurationList)
        let aBakingAssetId = getAssetBakingAssetId(assetConfigurationList)
        let aOverCollateralPercent = getAssetOverCollateralPercent(assetConfigurationList)
        let aMinRequiredPool = getAssetMinRequiredPoolAmount(assetConfigurationList)
        let aPriceOracleAddress = getAssetPriceOracleAddress(assetConfigurationList)
        let aMinBuyPayment = getMinBuyPaymentPerAsset(assetConfigurationList)
        let aMinSellPayment = getMinSellPaymentPerAsset(assetConfigurationList)
        let aBuyLockInterval = getBuyLockIntervalPerAsset(assetConfigurationList)
        let aSellLockInterval = getSellLockIntervalPerAsset(assetConfigurationList)
        let aBuyFee = getBuyFeePerAsset(assetConfigurationList)
        let aSellFee = getSellFeePerAsset(assetConfigurationList)
        let aRedemptionTimeoutBlocks = getRedemptionTimeoutBlocks(assetConfigurationList)
        let result = 
        [
            IntegerEntry(getPoolMakerParticipationAmountKey(toString(i.caller),assetAddress), currentPoolMakerBalance + i.payments[0].amount),
            IntegerEntry(getPoolMakerParticipationMaxAmountKey(toString(i.caller),assetAddress), 
                if(maxPoolMakerBalance < currentPoolMakerBalance) 
                    then currentPoolMakerBalance 
                    else maxPoolMakerBalance),
            # check that liquidity pool size is enough to set READY status
            IntegerEntry(getAssetCurrrentPoolAmountKey(assetAddress),finalPoolAmount),
            IntegerEntry(getAssetMaxPoolAmountKey(assetAddress),
                if(maxPoolAmount < finalPoolAmount)
                    then finalPoolAmount 
                        else maxPoolAmount),
            # todo: think how to avoid unnecessary key rewriting in case status remains the same
            DeleteEntry(getAssetConfigKey(assetAddress)),
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(aCode,aID,finalPoolStatus,aPriceDecimals,aBakingAssetId,aOverCollateralPercent,
                    aMinRequiredPool,aPriceOracleAddress,aMinBuyPayment,aMinSellPayment,aBuyLockInterval,aSellLockInterval,aBuyFee, aSellFee, aRedemptionTimeoutBlocks))
            ]  
        # in case synthetic asset is in ISSUED status, immediatelly transfer amount to asset contract
        if(currentPoolStatus == assetStatus._3) then 
            result :+ ScriptTransfer(addressFromStringValue(assetAddress), attachedPayment.amount, neutrinoAssetId)
            else result       
    }
}

# Issue new synthetic asset
# [called by pacemaker]
@Callable(i)
func activateAsset(assetCode: String) = { 
    # todo: create debt asset, save its id in configuration
    # move all 
    let assetConfigurationList = getAssetConfigArray(assetCode)
    let currentAssetPoolAmount = getAssetCurrentPoolAmount(assetCode) 
    let assetAddress =  getAssetAddressByCode(assetCode)
    let setAssetScriptTXID = getString(addressFromStringValue(assetAddress),setAssetScriptTxIdKey).valueOrErrorMessage("Asset is not ready to be activated. Script TX ID is absent.")

     # collect all keys for config
    let aCode = getAssetCode(assetConfigurationList) 
    let aID = getAssetID(assetConfigurationList)
    let aPriceDecimals = getAssetPriceDecimals(assetConfigurationList)
    let aBakingAssetId = getAssetBakingAssetId(assetConfigurationList)
    let aOverCollateralPercent = getAssetOverCollateralPercent(assetConfigurationList)
    let aMinRequiredPool = getAssetMinRequiredPoolAmount(assetConfigurationList)
    let aPriceOracleAddress = getAssetPriceOracleAddress(assetConfigurationList)
    let aMinBuyPayment = getMinBuyPaymentPerAsset(assetConfigurationList)
    let aMinSellPayment = getMinSellPaymentPerAsset(assetConfigurationList)
    let aBuyLockInterval = getBuyLockIntervalPerAsset(assetConfigurationList)
    let aSellLockInterval = getSellLockIntervalPerAsset(assetConfigurationList)
    let aBuyFee = getBuyFeePerAsset(assetConfigurationList)
    let aSellFee = getSellFeePerAsset(assetConfigurationList)
    let aRedemptionTimeoutBlocks = getRedemptionTimeoutBlocks(assetConfigurationList)

     # check asset exists
     if(i.caller != this) 
        then throw("Operation is allowed for contract holder ATM.") 
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")
    else if(currentAssetPoolAmount < minimumPoolFunding)
        then throw("Cannot issue asset as liquidity pool amount (" + toString(currentAssetPoolAmount) + ") is less than required (" + toString(minimumPoolFunding) + ")")
    else {
        let setAssetScriptHeight = transactionHeightById(fromBase58String(setAssetScriptTXID)).valueOrErrorMessage("Asset is not ready to be activated. Set script TX is not applied yet.")
        let issueDebt = Reissue(debtToken,10000000,true)
        [
            IntegerEntry(getAssetActivateHeightKey(assetAddress), height),
            DeleteEntry(getAssetConfigKey(assetAddress)),
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(aCode,aID,assetStatus._3,aPriceDecimals,aBakingAssetId,aOverCollateralPercent,
                    aMinRequiredPool,aPriceOracleAddress,aMinBuyPayment,aMinSellPayment,aBuyLockInterval,aSellLockInterval,aBuyFee, aSellFee, aRedemptionTimeoutBlocks)),
            ScriptTransfer(addressFromStringValue(assetAddress),currentAssetPoolAmount,neutrinoAssetId),
            issueDebt,
            ScriptTransfer(addressFromStringValue(assetAddress),10000000,debtToken)
        ]
    } 
}

# Create an application to redeem specified amount from pool. 
# It is a delayed operation, as necessary amount have to be unstaked and further transfered from asset contract to factory contract.
# [called by pool maker]
@Callable(i)
func redeemFromPool(amount: Int, assetCode: String) = {
    let assetConfigurationList = getAssetConfigArray(assetCode)
    let assetAddress = getAssetAddressByCode(assetCode)
    let callerAddress = toString(i.caller)
    let totalAmountInPoolByCaller = getPoolMakerParticipationAmount(assetAddress, callerAddress)
    let lockedAmountByPoolMaker = getPoolMakerLockedAmount(assetAddress, callerAddress)
    # validate that asset exists 
    if(i.caller != this) 
        then throw("Operation is allowed for contract holder ATM.") 
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")
    # validate that amount is correct and less or equals to total funds belongs to this caller and validate that caller has participated in pool
    else if(amount < 0 || totalAmountInPoolByCaller == 0 || totalAmountInPoolByCaller < amount)
        then throw("Cannot find pool maker by address " + callerAddress + " or amount passed is not correct.")
    # validate that caller doesn't have any funds locked for withdraw
    else if(lockedAmountByPoolMaker > 0) 
        then throw("Pool maker already has initiated redemption that is not withdrawn yet.")
    else {
        [
            IntegerEntry(getPoolMakerLockedAmountKey(assetAddress, callerAddress), amount),
            IntegerEntry(getPoolMakerUnlockHeightKey(assetAddress, callerAddress), height + getRedemptionTimeoutBlocks(assetConfigurationList))
        ]
    }
}

# Cancel an application to redeem from pool. 
# [called by pool maker]
@Callable(i)
func withdraw(assetCode: String) = {
     let assetConfigurationList = getAssetConfigArray(assetCode)
    let assetAddress = getAssetAddressByCode(assetCode)
    let priceOracleAddress = addressFromStringValue(getAssetPriceOracleAddress(assetConfigurationList))
    let callerAddress = toString(i.caller)
    let syntheticAssetInfo = assetInfo(fromBase58String(assetAddress)).valueOrErrorMessage("Cannot find asset by id " + assetAddress)
    let totalUSDNBalanceOnContract = assetBalance(this, neutrinoAssetId)


    let totalAmountInPoolByPoolMaker = getPoolMakerParticipationAmount(assetAddress, callerAddress)
    let lockedAmountByPoolMaker = getPoolMakerLockedAmount(assetAddress, callerAddress)
    let minWithdrawHeight = getPoolMakerUnlockHeight(assetAddress, callerAddress)
    let poolMaketProportion = getAssetMaxPoolAmount(assetAddress) / getPoolMakerParticipationMaxAmount(assetAddress, callerAddress)
    # validate that asset exists 
    if(i.caller != this) 
        then throw("Operation is allowed for contract holder ATM.") 
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")
    # validate that caller has participated in pool and exist
    else if(totalAmountInPoolByPoolMaker == 0)
        then throw("Cannot find pool maker by address " + callerAddress + " or no locked amount.")
    else if(minWithdrawHeight < height) 
        then throw("Please wait " + toString(minWithdrawHeight) + " before withdraw.")
    else {
        # todo: check that small amounts shouldn't be withdrawned -> set some min withdraw limit
        # todo: in case amount to withdraw left is less than withdraw limit - fulfull it in one operation
        let assetEmission = syntheticAssetInfo.quantity
        let currentPrice = getAssetPrice(priceOracleAddress)
        let poolMakerLockedAmount = getPoolMakerLockedAmount(assetAddress, callerAddress)
        # 3. calculate overcollaterlPrice = price * overcollateral rate
        let priceWithOvercollateralRate = getAssetOverCollateralPercent(assetConfigurationList) * currentPrice
        let usdnNeededToCoverEmission = priceWithOvercollateralRate * assetEmission
        # in this case we can consider withdraw
        if(totalUSDNBalanceOnContract > usdnNeededToCoverEmission)
            then {
                # this is the base to calculate amout pool maker can withdraw atm
                let amoutAvailableToExitFromPool = totalUSDNBalanceOnContract - usdnNeededToCoverEmission
                let amountForWithdraw = poolMaketProportion * amoutAvailableToExitFromPool 
                let finalLockedAmount = getPoolMakerLockedAmount(assetAddress, callerAddress) - amountForWithdraw
                [
                    IntegerEntry(getAssetCurrrentPoolAmountKey(assetAddress), getAssetCurrentPoolAmount(assetAddress) - amountForWithdraw),
                    IntegerEntry(getPoolMakerParticipationAmountKey(assetAddress, callerAddress), getPoolMakerParticipationAmount(assetAddress,callerAddress) - amountForWithdraw),
                    # todo: consider to delete entry in case it became zero
                    IntegerEntry(getPoolMakerLockedAmountKey(assetAddress, callerAddress), finalLockedAmount),
                    ScriptTransfer(addressFromStringValue(callerAddress),amountForWithdraw,neutrinoAssetId)
                ]
            }
        else {
            []
        }
    }
    # calculate poolMakerProportion based on max_pool_balance
    # calculations for pool maker money to return: 
    # 1. usdnBalance = take usdn balance on the contract
    # 2. emission = take synthetic asset emission
    # 3. calculate overcollaterlPrice = price * overcollateral rate
    # 4. calculate usdn need to cover emissionCoveredByUsnd =  emission * overcollaterlPrice
    # 5. if usdnBalance > emissionCoveredByUsnd then pool maker can withdraw
    # ---- 6. amountForCalculation = if usdnBalance > poolMakersBalance then took as base for calculations poolMakersBalance, otherwise usdnBalance
    # 7. totalAmountForPoolMaker = amountForCalculation * poolMakerProportion  
}

