{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

#-------------------Private functions----------------------
func convertJsonArrayToList(jsonArray: String, splitSymbol: String) = {
   jsonArray.split(splitSymbol) 
}

func getStringByAddressAndKey(address: Address, key: String) = {
     getString(address, key).valueOrElse("")
}

func getBoolByKey(key: String) = {
    getBoolean(this, key).valueOrElse(false)
}

#------------------ Variables -----------------------
let keyAssetCode                = 1
let keyAssetId                  = 2
let keyAssetStatus              = 3
let keyAssetPriceDecimals       = 4
let keyAssetBakingAsset         = 5
let keyOvercollateralPercentage = 6
let keyMinPool                  = 7
let keyPriceOracleAddress       = 8
let keyMinBuyPayment            = 9
let keyMinSellPayment           = 10
let keyBuyLockInterval          = 11
let keySellLockInterval         = 12
let keyBuyFee                   = 13
let keySellFee                  = 14
let keyPoolRedemptionTimeout    = 15
let adminPublicKey              = "$ADMINPK"

#------------------- Constructor -------------------------
let neutrinoContractAddressKey  = "%s%s__commonConfig__neutrinoContractAddress"
let minimunPoolFundingAmountKey = "%s%s__commonConfig__minimumPoolFundingAmount"
let isInitializedKey            = "%s%s__commonConfig__initialized"
let currentAssetIndexKey        = "%s%s__commonConfig__predefinedAssetsActiveIndex" 
let assetsAddressListKey        = "%s%s__commonConfig__predefinedAssetsList"
let debtTokenIdKey              = "%s%s__commonConfig__debtAssetId"

#------------------- Keys on other contracts ---------------------------------
let neutrinoAssetIdKey          = "neutrino_asset_id" # from Neutrino contract
let nsbtAssetIdKey              = "bond_asset_id"         # from Neutrino contract
let defoAssetIdKey              = "%s__defoAssetId" # key on synthetic asset contract that represents issued asset id
let setAssetScriptTxIdKey       = "%s__assetScriptTxId" # key on synthetic asset contract that represents issued asset transaction id

#---------------------- Keys on current contract --------------------------
# main config of an asset
func getAssetConfigKey(assetAddress: String) = "%s%s%s__defoAsset__" + assetAddress + "__config"

# dynamic asset parameters
func getAssetPriceKey(assetCode: String)                 = "%s%s__assetPrice__" + assetCode
func getAssetInitHeightKey(assetAddress: String)         = "%s%s%s__defoAsset__" + assetAddress + "__initHeight" 
func getAssetActivateHeightKey(assetAddress: String)     = "%s%s%s__defoAsset__" + assetAddress + "__activateHeight" 
func getAssetCurrrentPoolAmountKey(assetAddress: String) = "%s%s%s__defoAsset__" + assetAddress + "__currentPool"
func getAssetMaxPoolAmountKey(assetAddress: String)      = "%s%s%s__defoAsset__" + assetAddress + "__maxPool"
func getAssetMetaKey(assetAddress: String)               = "%s%s%s__defoAsset__" + assetAddress +  "__meta" 
func getAssetAddressByCodeKey(assetCode: String)         = "%s%s%s__defoAsset__" + assetCode +  "__addressByAssetCode"
func getAssetAddressByAssetIdKey(assetId: String)        = "%s%s%s__defoAsset__" + assetId + "__addressByAssetId" # key on factory contract that links issued asset id with synthetic asset contract

func getPoolMakerParticipationAmountKey(assetAddress: String, poolMakerAddress: String)    = "%s%s%s%s__pool__" + assetAddress + "__" + poolMakerAddress + "__amount"
func getPoolMakerParticipationMaxAmountKey(assetAddress: String, poolMakerAddress: String) = "%s%s%s%s__pool__" + assetAddress + "__" + poolMakerAddress + "__maxAmount"
func getPoolMakerLockedAmountKey(assetAddress: String, poolMakerAddress: String)           = "%s%s%s%s__pool__" + assetAddress + "__" + poolMakerAddress + "__lockedAmount"
func getPoolMakerUnlockHeightKey(assetAddress: String, poolMakerAddress: String)           = "%s%s%s%s__pool__" + assetAddress + "__" + poolMakerAddress + "__unlockHeight"

func getAssetConfigArray(assetAddress: String) = 
        convertJsonArrayToList(
            getStringByAddressAndKey(this, getAssetConfigKey(assetAddress)).valueOrErrorMessage("No DEFO Asset " + assetAddress + "config present"),
            "__")

#-------------------Global variables-------------------------
let neutrinoContract         =  addressFromStringValue(getString(this,neutrinoContractAddressKey).valueOrErrorMessage("No neutrino contract specified."))
let neutrinoAssetId          =  fromBase58String(getString(neutrinoContract, neutrinoAssetIdKey).valueOrErrorMessage("No USDN asset id found."))
let nsbtAssetId              =  fromBase58String(getString(neutrinoContract, nsbtAssetIdKey).valueOrErrorMessage("No NSBT asset id found"))
let minimumPoolFunding       =  getInteger(this, minimunPoolFundingAmountKey).valueOrErrorMessage("Minimum pool funding amount is not specified.")
let assetStatus              =  ("PROPOSED","READY","ISSUED")
let predefinedAssetContracts =  getString(this, assetsAddressListKey).valueOrErrorMessage("No pool of predeployed asset contracts found.")
let predefinedAssetsList     =  convertJsonArrayToList(predefinedAssetContracts, ",")
let currentAssetIndex        =  getInteger(this, currentAssetIndexKey).valueOrElse(0)
let debtToken                =  fromBase58String(getString(this,debtTokenIdKey).valueOrErrorMessage("No debt token found"))
let multiplicator            =  1000000
let debtTokenReissueAmount   =  10000000 * multiplicator

#-------------------Get functions-----------------------
func getAssetAddressByCode(assetSymbol: String)               = getString(this, getAssetAddressByCodeKey(assetSymbol)).valueOrElse("")
func getAssetCode(assetConfig: List[String])                  = assetConfig[keyAssetCode]
func getAssetID(assetConfig: List[String])                    = assetConfig[keyAssetId]
func getAssetStatus(assetConfig: List[String])                = assetConfig[keyAssetStatus]
func getAssetPriceDecimals(assetConfig: List[String])         = parseIntValue(assetConfig[keyAssetPriceDecimals])
func getAssetBakingAssetId(assetConfig: List[String])         = assetConfig[keyAssetBakingAsset]
func getAssetOverCollateralPercent(assetConfig: List[String]) = parseIntValue(assetConfig[keyOvercollateralPercentage])
func getAssetMinRequiredPoolAmount(assetConfig: List[String]) = parseIntValue(assetConfig[keyMinPool])
func getAssetPriceOracleAddress(assetConfig: List[String])    = assetConfig[keyPriceOracleAddress]
func getMinBuyPaymentPerAsset(assetConfig: List[String])      = parseIntValue(assetConfig[keyMinBuyPayment]) # in usdn
func getMinSellPaymentPerAsset(assetConfig: List[String])     = parseIntValue(assetConfig[keyMinSellPayment]) 
func getBuyLockIntervalPerAsset(assetConfig: List[String])    = parseIntValue(assetConfig[keyBuyLockInterval])
func getSellLockIntervalPerAsset(assetConfig: List[String])   = parseIntValue(assetConfig[keySellLockInterval])
func getBuyFeePerAsset(assetConfig: List[String])             = parseIntValue(assetConfig[keyBuyFee])
func getSellFeePerAsset(assetConfig: List[String])            = parseIntValue(assetConfig[keySellFee])
func getRedemptionTimeoutBlocks(assetConfig: List[String])    = parseIntValue(assetConfig[keyPoolRedemptionTimeout])

func getAssetInitHeight(assetAddress: String)        = getInteger(this,getAssetInitHeightKey(assetAddress)).valueOrElse(0)
func getAssetActivateHeight(assetAddress: String)    = getInteger(this,getAssetActivateHeightKey(assetAddress)).valueOrElse(0)
func getAssetCurrentPoolAmount(assetAddress: String) = getInteger(this,getAssetCurrrentPoolAmountKey(assetAddress)).valueOrElse(0) 
func getAssetMaxPoolAmount(assetAddress: String)     = getInteger(this,getAssetMaxPoolAmountKey(assetAddress)).valueOrElse(0)

func getAssetMeta(assetAddress: String) = getString(this,getAssetMetaKey(assetAddress)).valueOrElse("")

func getPoolMakerParticipationAmount(assetAddress: String, poolMakerAddress: String)    = getInteger(this,getPoolMakerParticipationAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerParticipationMaxAmount(assetAddress: String, poolMakerAddress: String) = getInteger(this,getPoolMakerParticipationMaxAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerLockedAmount(assetAddress: String, poolMakerAddress: String)           = getInteger(this,getPoolMakerLockedAmountKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getPoolMakerUnlockHeight(assetAddress: String, poolMakerAddress: String)           = getInteger(this,getPoolMakerUnlockHeightKey(assetAddress, poolMakerAddress)).valueOrElse(0)
func getAssetPrice(priceOracleAddress: Address, assetCode: String)                      = getInteger(priceOracleAddress, getAssetPriceKey(assetCode)).valueOrErrorMessage("No Asset price found")

func composeAssetConfigurationString(assetCode: String, assetId: String, assetStatus: String, priceDecimals: Int, backingAssetId: String, overCollateralPercent: Int, minPool: Int, priceOracleAddress: String,  
                  minBuyPayment: Int, minSellPayment: Int, buyLockInterval: Int, sellLockInterval: Int, buyFee: Int, sellFee: Int, poolRedemptionTimeout: Int) = {
    "%s%s%s%d%s%d%d%s%d%d%d%d%d%d%d" + "__" + 
    assetCode                        + "__" + 
    assetId                          + "__" + 
    assetStatus                      + "__" + 
    toString(priceDecimals)          + "__" + 
    backingAssetId                   + "__" +
    toString(overCollateralPercent)  + "__" + 
    toString(minPool)                + "__" + 
    priceOracleAddress               + "__" + 
    toString(minBuyPayment)          + "__" +
    toString(minSellPayment)         + "__" + 
    toString(buyLockInterval)        + "__" + 
    toString(sellLockInterval)       + "__" + 
    toString(buyFee)                 + "__" + 
    toString(sellFee)                + "__" + 
    toString(poolRedemptionTimeout)
}

@Callable(i)
func init(neutrinoContractAddress: String, minimunPoolFundingAmount: Int, predefinedAssetList: String, currentAssetIndex: Int) = {
     if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == true) 
        then throw("Contract was already initialized.")
    else {
        # TODO:
        # 6. cross  exchange coefficient
        let issueDebt =  Issue("DEFO_DEBT", "DEFO Debt Token.", 1, 6, true)
        let debtTokenId = calculateAssetId(issueDebt)
        [ 
            StringEntry(neutrinoContractAddressKey, neutrinoContractAddress),
            IntegerEntry(minimunPoolFundingAmountKey, minimunPoolFundingAmount),
            StringEntry(assetsAddressListKey, predefinedAssetList),
            IntegerEntry(currentAssetIndexKey, currentAssetIndex),
            StringEntry(debtTokenIdKey, toBase58String(debtTokenId)),
            BooleanEntry(isInitializedKey, true),
            issueDebt,
            Burn(debtTokenId, 1)
        ]
    } 
}

# Propose new synthetic asset
# [called by user]
# TODO: add payment to initiate pool by firts pool  maker
@Callable(i)
func proposeAsset(assetCode: String, meta: String, minPool: Int, priceOracleAddress: String, overCollateralPercent: Int, backingAssetId: String, 
                  priceDecimals: Int, minBuyPayment: Int, minSellPayment: Int, buyLockInterval: Int, sellLockInterval: Int, buyFee: Int, sellFee: Int, 
                  poolRedemptionTimeout: Int) = {
    if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(fromBase58String(backingAssetId) != neutrinoAssetId) 
        then throw("Baking asset id could be USDN only.")
    else if (getAssetAddressByCode(assetCode) != "") 
        then throw("Asset with passed code " + assetCode + " has already been proposed.")
    else if(minPool < minimumPoolFunding)
       then throw("Minimum pool amount should be greater or equals to " + toString(minimumPoolFunding))
    else if(overCollateralPercent < 0 || priceDecimals < 0  || minBuyPayment < 0 || minSellPayment < 0 || buyLockInterval < 0 || sellLockInterval < 0 
            || buyFee < 0 || sellFee < 0) 
        then throw("One of the passed parameters is invalid.")
    else {
        let priceOracleAddressValid = addressFromStringValue(priceOracleAddress).valueOrErrorMessage("Passed Price Oracle Address is not valid.")
        let assetAddress = predefinedAssetsList[currentAssetIndex]
        let defoAssetId = getString(addressFromString(assetAddress).valueOrErrorMessage(""), defoAssetIdKey).valueOrErrorMessage("No defo asset ID found.")
        
        [
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(
                    assetCode,
                    defoAssetId,
                    assetStatus._1,
                    priceDecimals,
                    backingAssetId,
                    overCollateralPercent,
                    minPool,
                    priceOracleAddress,
                    minBuyPayment,
                    minSellPayment,
                    buyLockInterval,
                    sellLockInterval,
                    buyFee, 
                    sellFee,
                    poolRedemptionTimeout)
                    ), 

            StringEntry(getAssetAddressByCodeKey(assetCode), assetAddress),  
            StringEntry(getAssetMetaKey(assetAddress), meta),
            IntegerEntry(getAssetInitHeightKey(assetAddress), height),
            IntegerEntry(currentAssetIndexKey, currentAssetIndex + 1),
            StringEntry(getAssetAddressByAssetIdKey(defoAssetId),assetAddress)
        ]
    }
}

# Fund specified synthetic asset liquidity pool
# [called by user]
@Callable(i)
func fundLiquidityPool(assetCode: String) = {
    let assetAddress = getAssetAddressByCode(assetCode)
    let assetConfigurationList = getAssetConfigArray(assetAddress)
    let attachedPayment = (i.payments[0]).value()
    if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(attachedPayment.assetId != neutrinoAssetId) 
        then throw("Liquidity pool could be funded with USDN only.")
    # check payment amount more than 0
    else if(attachedPayment.amount == 0) 
        then throw("Incorrect attached payment amount.")
    # check asset exists
    else if(assetAddress == "")
        then throw("Cannot find liquidity pool for asset " + assetCode + ".")
    else {
        let finalPoolAmount = attachedPayment.amount + getAssetCurrentPoolAmount(assetAddress)
        let maxPoolAmount = getAssetMaxPoolAmount(assetAddress)
        
        let currentPoolMakerBalance = getPoolMakerParticipationAmount(assetAddress, toString(i.caller))
        let maxPoolMakerBalance = getPoolMakerParticipationMaxAmount(assetAddress, toString(i.caller))

        let currentPoolStatus = getAssetStatus(assetConfigurationList)
        let finalPoolStatus = if((finalPoolAmount >= getAssetMinRequiredPoolAmount(assetConfigurationList)) && (currentPoolStatus == assetStatus._1))
                    then assetStatus._2 
                        else currentPoolStatus
        
        # collect all keys for config
        let aCode = getAssetCode(assetConfigurationList) 
        let aID = getAssetID(assetConfigurationList)
        let aPriceDecimals = getAssetPriceDecimals(assetConfigurationList)
        let aBakingAssetId = getAssetBakingAssetId(assetConfigurationList)
        let aOverCollateralPercent = getAssetOverCollateralPercent(assetConfigurationList)
        let aMinRequiredPool = getAssetMinRequiredPoolAmount(assetConfigurationList)
        let aPriceOracleAddress = getAssetPriceOracleAddress(assetConfigurationList)
        let aMinBuyPayment = getMinBuyPaymentPerAsset(assetConfigurationList)
        let aMinSellPayment = getMinSellPaymentPerAsset(assetConfigurationList)
        let aBuyLockInterval = getBuyLockIntervalPerAsset(assetConfigurationList)
        let aSellLockInterval = getSellLockIntervalPerAsset(assetConfigurationList)
        let aBuyFee = getBuyFeePerAsset(assetConfigurationList)
        let aSellFee = getSellFeePerAsset(assetConfigurationList)
        let aRedemptionTimeoutBlocks = getRedemptionTimeoutBlocks(assetConfigurationList)
        let newPoolMakerBalance = currentPoolMakerBalance + i.payments[0].amount
        let result = 
        [
            IntegerEntry(getPoolMakerParticipationAmountKey(assetAddress, toString(i.caller)), newPoolMakerBalance),
            IntegerEntry(getPoolMakerParticipationMaxAmountKey(assetAddress, toString(i.caller)), 
                if(maxPoolMakerBalance < newPoolMakerBalance) 
                    then newPoolMakerBalance 
                    else maxPoolMakerBalance),
            # check that liquidity pool size is enough to set READY status
            IntegerEntry(getAssetCurrrentPoolAmountKey(assetAddress),finalPoolAmount),
            IntegerEntry(getAssetMaxPoolAmountKey(assetAddress),
                if(maxPoolAmount < finalPoolAmount)
                    then finalPoolAmount 
                        else maxPoolAmount),
            # todo: think how to avoid unnecessary key rewriting in case status remains the same
            DeleteEntry(getAssetConfigKey(assetAddress)),
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(aCode,aID,finalPoolStatus,aPriceDecimals,aBakingAssetId,aOverCollateralPercent,
                    aMinRequiredPool,aPriceOracleAddress,aMinBuyPayment,aMinSellPayment,aBuyLockInterval,aSellLockInterval,aBuyFee, aSellFee, aRedemptionTimeoutBlocks))
        ]  
        # in case synthetic asset is in ISSUED status, immediatelly transfer amount to asset contract
        if(currentPoolStatus == assetStatus._3) then 
            result :+ ScriptTransfer(addressFromStringValue(assetAddress), attachedPayment.amount, neutrinoAssetId)
            else result       
    }
}

# Issue new synthetic asset
# [called by pacemaker]
@Callable(i)
func activateAsset(assetCode: String) = { 
    let assetAddress = getAssetAddressByCode(assetCode)
    let assetConfigurationList = getAssetConfigArray(assetAddress)
    let currentAssetPoolAmount = getAssetCurrentPoolAmount(assetAddress) 
    
    #let setAssetScriptTXID = getString(addressFromStringValue(assetAddress),setAssetScriptTxIdKey).valueOrErrorMessage("Asset is not ready to be activated. Script TX ID is absent.")

    # collect all keys for config
    let aCode = getAssetCode(assetConfigurationList) 
    let aCurrentStatus = getAssetStatus(assetConfigurationList)
    let aID = getAssetID(assetConfigurationList)
    let aPriceDecimals = getAssetPriceDecimals(assetConfigurationList)
    let aBakingAssetId = getAssetBakingAssetId(assetConfigurationList)
    let aOverCollateralPercent = getAssetOverCollateralPercent(assetConfigurationList)
    let aMinRequiredPool = getAssetMinRequiredPoolAmount(assetConfigurationList)
    let aPriceOracleAddress = getAssetPriceOracleAddress(assetConfigurationList)
    let aMinBuyPayment = getMinBuyPaymentPerAsset(assetConfigurationList)
    let aMinSellPayment = getMinSellPaymentPerAsset(assetConfigurationList)
    let aBuyLockInterval = getBuyLockIntervalPerAsset(assetConfigurationList)
    let aSellLockInterval = getSellLockIntervalPerAsset(assetConfigurationList)
    let aBuyFee = getBuyFeePerAsset(assetConfigurationList)
    let aSellFee = getSellFeePerAsset(assetConfigurationList)
    let aRedemptionTimeoutBlocks = getRedemptionTimeoutBlocks(assetConfigurationList)

    if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(aCurrentStatus != assetStatus._2) 
        then throw("Asset is not in READY status. Current status is " + aCurrentStatus + ".")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")
    else if(currentAssetPoolAmount < minimumPoolFunding)
        then throw("Cannot issue asset as liquidity pool amount (" + toString(currentAssetPoolAmount) + ") is less than required (" + toString(minimumPoolFunding) + ")")
    else {
        #let setAssetScriptHeight = transactionHeightById(fromBase58String(setAssetScriptTXID)).valueOrErrorMessage("Asset is not ready to be activated. Set script TX is not applied yet.")
        let issueDebt = Reissue(debtToken, debtTokenReissueAmount, true)
        [
            IntegerEntry(getAssetActivateHeightKey(assetAddress), height),
           
            DeleteEntry(getAssetConfigKey(assetAddress)),
            StringEntry(
                getAssetConfigKey(assetAddress), 
                composeAssetConfigurationString(aCode,aID,assetStatus._3,aPriceDecimals,aBakingAssetId,aOverCollateralPercent,
                    aMinRequiredPool,aPriceOracleAddress,aMinBuyPayment,aMinSellPayment,aBuyLockInterval,aSellLockInterval,aBuyFee, aSellFee, aRedemptionTimeoutBlocks)),
            # reissue new portion of Debt for new asset
            issueDebt,        
            # transfer asset pool to asset address
            ScriptTransfer(addressFromStringValue(assetAddress), currentAssetPoolAmount, neutrinoAssetId),
            # transfer debt tokens to asset address
            ScriptTransfer(addressFromStringValue(assetAddress), debtTokenReissueAmount, debtToken)
        ]
    } 
}

# Create an application to redeem specified amount from pool. 
# It is a delayed operation, as necessary amount have to be unstaked and further transfered from asset contract to factory contract.
# [called by pool maker]
@Callable(i)
func redeemFromPool(assetCode: String, amount: Int) = {

    let assetAddress = getAssetAddressByCode(assetCode)
    let assetConfigurationList = getAssetConfigArray(assetAddress)
    let callerAddress = toString(i.caller)
    let totalAmountInPoolByCaller = getPoolMakerParticipationAmount(assetAddress, callerAddress)
    let lockedAmountByPoolMaker = getPoolMakerLockedAmount(assetAddress, callerAddress)

    if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")

    # validate that amount is correct and less or equals to total funds belongs to this caller and validate that caller has participated in pool
    else if(amount < 0 || totalAmountInPoolByCaller == 0 || totalAmountInPoolByCaller < amount)
        then throw("Cannot find pool maker by address " + callerAddress + " or amount passed is not correct.")
    # validate that caller doesn't have any funds locked for withdraw
    else if(lockedAmountByPoolMaker > 0) 
        then throw("Pool maker already has initiated redemption that is not withdrawn yet.")
    else {
        [   
            IntegerEntry(getPoolMakerLockedAmountKey(assetAddress, callerAddress), amount),
            IntegerEntry(getPoolMakerUnlockHeightKey(assetAddress, callerAddress), height + getRedemptionTimeoutBlocks(assetConfigurationList))
        ]
    }
}

# Cancel an application to redeem from pool. 
# how to:
    #calculate poolMakerProportion based on max_pool_balance
    # calculations for pool maker money to return: 
    # 1. usdnBalance = take usdn balance on the contract
    # 2. emission = take synthetic asset emission
    # 3. calculate overcollaterlPrice = price * overcollateral rate
    # 4. calculate usdn need to cover emissionCoveredByUsnd =  emission * overcollaterlPrice
    # 5. if usdnBalance > emissionCoveredByUsnd then pool maker can withdraw
    # ---- 6. amountForCalculation = if usdnBalance > poolMakersBalance then took as base for calculations poolMakersBalance, otherwise usdnBalance
    # 7. totalAmountForPoolMaker = amountForCalculation * poolMakerProportion  
# [called by pool maker]
@Callable(i)
func withdraw(assetCode: String) = {
    let assetConfigurationList = getAssetConfigArray(assetCode)
    let assetAddress = getAssetAddressByCode(assetCode)
    let priceOracleAddress = addressFromStringValue(getAssetPriceOracleAddress(assetConfigurationList))
    let callerAddress = toString(i.caller)
    let syntheticAssetInfo = assetInfo(fromBase58String(assetAddress)).valueOrErrorMessage("Cannot find asset by id " + assetAddress)
    let totalUSDNBalanceOnContract = assetBalance(this, neutrinoAssetId)
    let totalAmountInPoolByPoolMaker = getPoolMakerParticipationAmount(assetAddress, callerAddress)
    let lockedAmountByPoolMaker = getPoolMakerLockedAmount(assetAddress, callerAddress)
    let minWithdrawHeight = getPoolMakerUnlockHeight(assetAddress, callerAddress)
    let poolMaketProportion = getAssetMaxPoolAmount(assetAddress) / getPoolMakerParticipationMaxAmount(assetAddress, callerAddress)
    
    if (toBase58String(i.callerPublicKey) != adminPublicKey) then
        throw("Only Admin can perform contract operation.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(getBoolByKey(isInitializedKey) == false) 
        then throw("Contract is not yet ready.")
    else if(assetAddress == "")
        then throw("Cannot find asset " + assetCode + ".")
    # validate that caller has participated in pool and exist
    else if(totalAmountInPoolByPoolMaker == 0)
        then throw("Cannot find pool maker by address " + callerAddress + " or no locked amount.")
    else if(minWithdrawHeight < height) 
        then throw("Please wait " + toString(minWithdrawHeight) + " before withdraw.")
    else {
        # todo: check that small amounts shouldn't be withdrawned -> set some min withdraw limit
        # todo: in case amount to withdraw left is less than withdraw limit - fulfull it in one operation
        # todo: check that price per first block after withdraw height is writtrn (same logic as for neutrino swap?)
        let assetEmission = syntheticAssetInfo.quantity
        let currentPrice = getAssetPrice(priceOracleAddress, assetCode)
        let poolMakerLockedAmount = getPoolMakerLockedAmount(assetAddress, callerAddress)
        # 3. calculate overcollaterlPrice = price * overcollateral rate
        let priceWithOvercollateralRate = getAssetOverCollateralPercent(assetConfigurationList) * currentPrice
        let usdnNeededToCoverEmission = priceWithOvercollateralRate * assetEmission
        # in this case we can consider withdraw
        if(totalUSDNBalanceOnContract > usdnNeededToCoverEmission)
            then {
                # this is the base to calculate amout pool maker can withdraw atm
                let amoutAvailableToExitFromPool = totalUSDNBalanceOnContract - usdnNeededToCoverEmission
                let amountForWithdraw = poolMaketProportion * amoutAvailableToExitFromPool 
                let finalLockedAmount = getPoolMakerLockedAmount(assetAddress, callerAddress) - amountForWithdraw
                [
                    IntegerEntry(getAssetCurrrentPoolAmountKey(assetAddress), getAssetCurrentPoolAmount(assetAddress) - amountForWithdraw),
                    IntegerEntry(getPoolMakerParticipationAmountKey(assetAddress, callerAddress), getPoolMakerParticipationAmount(assetAddress,callerAddress) - amountForWithdraw),
                    # todo: consider to delete entry in case it became zero
                    IntegerEntry(getPoolMakerLockedAmountKey(assetAddress, callerAddress), finalLockedAmount),
                    ScriptTransfer(addressFromStringValue(callerAddress), amountForWithdraw, neutrinoAssetId)
                ]
            }
        else {
            []
        }
    }
}